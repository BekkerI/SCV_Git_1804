![Logo](logo.webp)
# Работа с Git
## 1. Проверка наличия установленного Git.
В терминале выполнить команду `git version`
Если Git установлен, появится сообщение с информацией о версии файла. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с сайта https://git-scm.com/downloads.
Устананвливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовании Git необходимо представиться. 
Для этого нужно ввести в терминале две команды:
```
git add <имя файла с расшириением>
```
git status
```
git log --oneline
```
Это команда совершит коммит, автомачиски индексируя файлы в репозитории.

## 4. Проверка состояния репозитория
Для проверки состояния репозитория,  необходимо воспользоваться командой:
```
git status
```
Это одна из важнейших команд Git, которая предоставляет нам информацию о состоянии репозитория, на какой ветке мы находимся, были внесены измения, наличие не отслеживаемых файлов. При наличии изменений, интерфейс Git подсвечивает их *красным* цветом и выдает подсказки, как исправить (зафиксировать) эти изменения.

**Рекомендуется использовать команду *git status* как можно чаще, чтобы проверять файл на отсутствие ошибок и вовремя индексировать и коммитить изменения в файле**

## 5. Запись изменений в репозитории.
Чтобы посмотреть состояние файлов в репозитории необходимо выполнить команду:
```
git status
```
Для того чтобы начать отслеживать новый файл, используется команда:
```
git add <имя файла с расширением>
```
При наборе имени файла достаточно ввести первые несколько символов и воспользоваться клавише *TAB*. Git самостоятельно допишет недостающие символы в название файла. Не забываем проверять название файла перед сохранением, особенно если в репозитории много файлов с похожими названиями.
При необходимости откатить *git add* **перед коммитом** необходимо воспользоваться командой:
```
git reset <имя файла с расширением>
```
для отмены изменений одного файла
```
git reset
```
для отмены всех изменений

## 6. Фиксация изменений в файле.
После выполнения команды *git add* и добавления файла к отслеживанию, необходимо зафиксировать измнения и добавить комментарий, для того чтобы иметь наглядную возможность просматривать какие операции производились с файлом.
Для этого необходимо воспользоваться командой:
```
git commit "коментарий"
```
Коментарий можно оставлять как на на любом языке и рекомендуется делать его подробным.

Можно обьединить команды *git add* и *git commit -m ""*.
Для этого можно воспользоваться командой:
```
git commit -am "коментарий"
```
Это команда совершит коммит, автомачиски индексируя файлы в репозитории.

Для внесения изменения в коммит, необходимо воспользоваться командой:
```
git commit -- amend
```
Она откроет редактор, в котором можно будет внести изменения в последний коммит.

Сообщение можно изменить и на прямую (без перехода в редактор) с помощью команды:
```
git commit --amend -m "Новый комментарий" 
```
Эта команда заменит последний коммит.

## 7. Просмотр изменений в файле.
Для того чтобы просмотреть список изменений, внесенный в репозиторий, необходимо воспользоваться командой:
``` 
git diff
```
По умолчанию она показывает изменения в файле не подготовленном для фиксации, т.е. перед командой *git add*

Для просмотра подготовленных изменений необходимо ввести команду:
```
git diff --staged
```

Кроме того команда *git diff* имеет режим подсветки с повышенной детализацией. В этом режиме добавленные и удаленные строки отделяются пробелами и изменения выделяются цветом:
```
git diff --color-words
```

## 8. Просмотр истории коммитов.
Для просмотра истории коммитов необходимо воспользоваться командой:
```
git log
```
Она подробно отобразит все коммиты, сделаные в репозитории с <Хэш-кодом> (имя или номер коммита), автором и датой. Сверху отображаются последние сделаные коммиты, для просмотра более ранних, необходимо прокрутить ленту сообщений в терминале вниз.

Можно вывести сокращенную версию истории коммитов командой:
```
git log --oneline
```
В этом случае отобразиться сокращенный <Хэш-код> коммита и его название.

Также возможно посмотреть дельту (разницу/diff) привнесенную каждым коммитом. Для этого к команде *git log* необходимо бодавить параметр *-p*
```
git log -p
```

Также, можно отобразить графически движение веток и коммитов добавив к команде *git log* параметр *--graph*
```
git log --graph
```

Для выхода из режима просмотра истории используется клавиша **Q**

## 9. Перемещения между сохранениями (коммитами).
Чтобы перейти к нужному сохранению (коммиту) можно использовать команду:
```
git checkout <хэш-код> достаточно взять от четырех символов хэш-кода
```
Пример использования команды `git checkout`:
```
git checkout 2f31c9e
```

Такой переход можно использовать только для просмотра!
Продолжить работу на файлом можно только после перехода на верх ветки, командой:
```
git checkout master
```
При помощи команды `git checkout` можно перемещаться между ветками
```
git checkout <имя ветки>
```
А также создать ветку и сразу перместиться на нее. Для этого необходимо добавить  параметр `-p`
```
git checkout -p <имя ветки>
```

## 10. Игнорирование файлов
В процессе работы над проектом не все файлы должны отслеживаться в Git. Временные файлы из среды разработки, тестовые выходные данные, журналы, изображения и т.д. Можно заставить Git игнориировать эти файлы и каталоги, то есть исключить их из отслеживания Git - путем создания одного или нескольких файлов [***.gitignore***](https://git-scm.com/docs/gitignore) в репозитории.
Каждая строка в ***.gitignore*** исключает файл или набор файлов соответствующих шаблону. 

[Полный синтаксис ***.gitignore***](https://git-scm.com/docs/gitignore) очень гибкий. Вот наиболее распространенные примеры:
```
- Игнорирование одного файла
  "имя файла.расширение"
- Игнорирование файлов по типу расширения
  "*.расширение"
- Добавление файла к отслеживанию из исключенного расширения
  "!имя файла.расширение" 
- Игнориирование каталога целиком
  "/имя каталога/"  
```
 ### Временно игнорировать измнения
 Можно попросить Git временно игнорировать изменения в файле. Сделать это можно командой:
 ```
 git update-index --skip-worktree "имя файла"
 ```
 Возобновить отслеживание c помощью команды:
 ```
 git update-index --no-skip-worktree "имя файла
 ```
 Этот подход полезен при настройке параметров или файлов конфигурации, которые являются частью источника проекта для собственной рабочей среды.
### Постоянное прекращение отслеживание файла
Если файл уже отслеживается Git, ***.gitignore*** не применяется, Git продолжит отслеживать изменения в этом файле. Для того чтобы прекратить отслеживание файла, необходимо воспользоваться следующим алгоритмом:
1. Добавить файл в папку ***.gitignore***
2. Выполнить следующую команду:
```
git rm --cached "имя файла"
```
3. Зафиксировать изменения и обновленный ***.gitignore*** в репозитории.

## 11. Работа с ветками в Git
Ветки в Git - это по сути последовательность коммитов, то есть с точки зрения реализации в Git - это ссылка на последний коммит. Ветки нужны для удобства совместной разработки проекта. В новом проекте по умолчанию создается основная ветка **мастер**, в ней хранится основной, стабильный код проекта. Создание новых веток позволяет работать над проеком не ограниченное количество участников без ущерба основному коду. 
Для создания новой ветки необходимо воспользоваться командой:
```
git branch <имя ветки>
```
Для перехода между ветками необходимо воспользоваться командой 
```
git checkout <имя ветки>
```
**После создания новой ветки необходимо перейти на нее для работы**
**Все изменения должным быть закоммичены**
Для того чтобы создать и **одновременно** перейти на новую ветку выполняется команда:
```
git checkout -b <имя ветки>
```
Для просмотра списка всех существующих веток используется команда:
```
git branch
```
В этом списке ветка, на которой мы находимся будет отмечена звездочкой `*`
Команда *git branch* с параметром *-r* покажет удаленные ветки
```
git branch -r
```
С параметром *-a* покажет все существующие и удаленные ветки
```
git branch -a
```
Если мы неудачно выбрали имя ветки и хотим его изменить, находясь в нужной ветке выполняем команду:
```
git branch -m <новое имя ветки>
```
Для удаления веток использууется команда:
```
git branch -d <имя ветки>
```
Для того чтобы удалить ветку мы должны находиться в ветке *master/origin/main*, а также ветка должна быть слита.
Если ветка не была слита, но мы уверены что хотим удалить ее, выполняем команду:
```
git branch -D <имя ветки>
```
Есть возможность перейти  на другую ветку не добавляя изменения в коммит, для этого существует команда:
```
git stash
```
Каждое применение *git stash* создает отдельный коммит, хэшкод которого записывается в стек Git. Откладывать изменение можно не ограниченное количество раз. Просмотреть список всех отложенных изменений можно командой:
```
git stash list
```
Чтобы достать изменения из стека и вернуть их в рабочую копию, нужно использовать команду
```
git stash pop
```

## 12. Слияние веток в Git.
**Слияние веток** – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней. 

**Сливаемая ветка** – та ветка, с которой мы берем изменения, чтобы влить их в целевую. 

**Целевая ветка** – та ветка, в которую мы сливаем наши изменения. 

**Ветка** – независимая последовательность коммитов. Ветки нужны, чтобы тестировать новые функции и распараллеливать работу над проектом. Обычно в основной ветке находится та же версия кода, что и в продакшене. То есть если в основную ветку попадут какие-то непроверенные изменения, код может сломаться и повлечь за собой поломку приложения у конечного пользователя. Поэтому во всех командах, работающих над серьезными проектами, принято, что в основной ветке находятся только протестированные изменения, которые в идеале не придется экстренно исправлять.
То есть общий ход нашей работы выглядит следующим образом:
- Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке. 
- Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код. 
- Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

Чтобы выполнить слиияние в Git существует команда:
```
git merge <имя ветки>
```
Эту команда выполняет ускоренное слияние, когда последний коммит текущей ветки является прямым продолжением целевой ветки. В этом случае для объединения истории Git не выполняет полноценное слияние, а просто переносит указатель текущей ветки в конец целевой ветки. Объединение историй проходит успешно, поскольку все коммиты целевой ветки теперь доступны из текущей ветки. Так, ускоренное слияние одной из функциональных веток с веткой main будет выглядеть следующим образом:

![logo](FastF.svg)

Однако выполнить ускоренное слияние не получится, если ветки после разделения развивались независимо друг от друга. Если до целевой ветки нет прямого пути, Git будет вынужден объединить их методом трехстороннего слияния. Такое слияние выполняется с помощью специального коммита, который служит для объединения двух историй. Метод называется трехсторонним, поскольку Git использует три коммита для создания коммита слияния (последние коммиты двух веток и общий родительский элемент).

![logo](3wayF.svg)

Если при ускоренном слиянии вам понадобится коммит слияния для учета изменений, вы можете выполнить команду *git merge* с параметром *--no-ff.*
```
git merge --no-ff <имя ветки>
```
Эта команда выполнит объединение указанной ветки с текущей с обязательным созданием коммита слияния (даже если слияние будет ускоренным). Это полезно для учета всех слияний в репозитории.

## 13. Решение конфликтов при слиянии веток.
Иногда процесс слияния не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить. В этом случае Git выдаст ошибку и нагляднов отобразит и в тексте и в термнале где имеено произошел конфликт. 
В файле текст будет обновлен и разделен символлами и по цветам.
```
<<<<<<<< HEAD - ветка main 
========
>>>>>>>> <имя сливаемой ветки>
```
Эти новые строки можно рассматривать как «разделители конфликта». Строка ======= является «центром» конфликта. Все содержимое между этим центром и строкой <<<<<<< HEAD находится в текущей ветке main, на которую ссылается указатель HEAD. А все содержимое между центром и строкой >>>>>>> <имя ветки> является содержимым ветки для слияния.

Самый простой способ разрешить конфликт является оторедактировать текст. Над каждым блоком текса, где нужно разрешить конфликт предложены кнопки:
```
оставить текущий вариант;
оставить входящий вариант;
остаавить оба варианта;
сравнить
```
После решения конфликта файл можно закоммитить.

### Общие инструменты для решения конфликтов при слиянии:
```
git status
```
Команда status часто используется во время работы с Git и помогает идентифицировать конфликтующие во время слияния файлы.
```
git log --merge
```
При передаче аргумента --merge для команды git log будет создан журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние.
```
git reset
```
Команду git reset можно использовать для разрешения конфликтов, возникающих во время выполнения слияния, чтобы восстановить заведомо удовлетворительное состояние конфликтующих файлов.
```
git merge --abort
```
При выполнении команды git merge с опцией --abort процесс слияния будет прерван, а ветка вернется к состоянию, в котором она находилась до начала слияния.

Очень подробную и расскрытую информацию можно посмотреть по [ссылке](https://git-scm.com/book/ru/v2/Инструменты-Git-Продвинутое-слияние)
